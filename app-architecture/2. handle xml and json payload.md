### Handle XML and JSON payload

We can  define two separate classes—one for handling JSON and one for XML—and encapsulate their differences using a common interface or an abstract class. This approach allows other classes to interact with the ExploreInput class in a polymorphic manner without worrying about whether the underlying payload is JSON or XML.


#### Steps:
- Define an Interface or Abstract Class: Define a common contract (interface or abstract class) that both JSON and XML implementations will adhere to.
- Create Concrete Classes: Implement two concrete classes, one for JSON and one for XML, that provide specific implementations for retrieving data.
- Use Polymorphism: The consumer classes can use the interface or abstract class to interact with either the JSON or XML implementation, abstracting away the differences.

#### Example Design:

* Step 1: Define the ExploreInput Interface

```groovy
interface ExploreInput {
    Object getData(String path)
}
```

This interface defines the getData method that each concrete class (JSON and XML) must implement.

* Step 2: Implement JSON and XML ExploreInput Classes

JSON Implementation:
```groovy
import groovy.json.JsonSlurper
import com.jayway.jsonpath.JsonPath

class JsonExploreInput implements ExploreInput {
    Map payload  // Parsed JSON payload

    JsonExploreInput(String jsonContent) {
        this.payload = new JsonSlurper().parseText(jsonContent)
    }

    @Override
    Object getData(String jsonPath) {
        // Use JsonPath to extract the data from the JSON payload
        return JsonPath.read(payload, jsonPath)
    }
}
```


XML Implementation:
```groovy
import groovy.xml.XmlSlurper

class XmlExploreInput implements ExploreInput {
    def payload  // Parsed XML payload (GPathResult)

    XmlExploreInput(String xmlContent) {
        this.payload = new XmlSlurper().parseText(xmlContent)
    }

    @Override
    Object getData(String xpath) {
        // Use XPath-like syntax with GPath
        return payload.depthFirst().findAll { it.name() == xpath }*.text()
    }
}

```

* Step 3: Create an Abstract Class (Optional)

If you want to provide some common logic or state between JSON and XML implementations, you can create an abstract class.

```groovy
abstract class AbstractExploreInput implements ExploreInput {
    String payloadType  // This can be used if needed

    AbstractExploreInput(String payloadType) {
        this.payloadType = payloadType
    }

    // Common logic can go here if needed
}
```

Both JsonExploreInput and XmlExploreInput can then extend this abstract class if they share some common behavior or fields.

* Step 4: Create a Factory for Dynamically Choosing the Implementation

You can add a factory or factory method to create the appropriate implementation based on the payload type (json or xml).

```groovy
class ExploreInputFactory {

    static ExploreInput createExploreInput(String payload, String payloadType) {
        if (payloadType == 'json') {
            return new JsonExploreInput(payload)
        } else if (payloadType == 'xml') {
            return new XmlExploreInput(payload)
        } else {
            throw new IllegalArgumentException("Unsupported payload type: $payloadType")
        }
    }
}
```

* Step 5: Consumer Code Using the ExploreInput Interface

Here’s how a consumer class could use the ExploreInput without needing to know if it’s dealing with JSON or XML:

```groovy
class Context {
    final ExploreInput exploreInput

    Context(ExploreInput exploreInput) {
        this.exploreInput = exploreInput
    }

    // Other methods to process the exploreInput data
    void processInput(String path) {
        def data = exploreInput.getData(path)
        println "Extracted Data: $data"
    }
}
```


* Step 6: Putting It All Together

```groovy
// Example JSON payload
def jsonPayload = '''{
    "person": {
        "name": "John",
        "age": 30,
        "address": {
            "city": "New York",
            "zipcode": "10001"
        }
    }
}'''

// Example XML payload
def xmlPayload = '''
<person>
    <name>John</name>
    <age>30</age>
    <address>
        <city>New York</city>
        <zipcode>10001</zipcode>
    </address>
</person>
'''

// Factory creates the appropriate ExploreInput instance based on payload type
ExploreInput jsonInput = ExploreInputFactory.createExploreInput(jsonPayload, 'json')
ExploreInput xmlInput = ExploreInputFactory.createExploreInput(xmlPayload, 'xml')

// Context class can now work with either JSON or XML
Context jsonContext = new Context(jsonInput)
jsonContext.processInput('$.person.name')  // JSONPath for JSON

Context xmlContext = new Context(xmlInput)
xmlContext.processInput('city')  // XPath-like for XML
```


#### Explanation:

- Interface (ExploreInput): Defines a contract that both JSON and XML handlers implement. This allows any consumer class (like Context) to interact with the data in the same way, regardless of the payload type.
- JsonExploreInput and XmlExploreInput: These are concrete implementations of ExploreInput. Each handles its respective payload type (JSON and XML) and knows how to extract data via JSONPath or XPath.
- Factory (ExploreInputFactory): This dynamically creates the appropriate ExploreInput instance based on the payload type.
- Consumer Class (Context): The Context class takes in an ExploreInput object and processes it without needing to know whether the data is in JSON or XML format. It only calls getData, relying on polymorphism.

#### Conclusion:

This approach abstracts the differences between JSON and XML payloads using polymorphism. The rest of the system interacts with the ExploreInput interface, so it doesn’t have to worry about the specifics of parsing JSON or XML. This is a clean design that makes the system extensible and easier to maintain, as you can add more payload types (e.g., YAML) in the future by simply creating new implementations of the ExploreInput interface.


In Groovy, when you have multiple implementations of a class or interface, and you want to dynamically  invoke one of them at runtime, you can use various approaches. Some common strategies include:

- Dependency Injection (DI): Using a DI framework like Spring or Guice to inject a specific implementation dynamically.
- Service Loader: Dynamically loading classes using the ServiceLoader mechanism.
- Factory Pattern: Using a factory class that returns a specific implementation based on some condition.
- Simple Conditional Logic: If the conditions for selecting an implementation are simple, you can use if-else or a configuration property to decide which class to instantiate.

